# -*- coding: utf-8 -*-
"""sesi04_bisection.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wusedyD9n0nVDEUjAkMiuH8Ox-Fq87QT
"""

import numpy as np
import math

def my_bisection (f,a, b, tol):
  # approximates a root, R, of f bounded
  # by a and b to within tolerance
  # | f(m) | < tol with m the mid point
  # between a and b Recursive implementation

  # check if a and b bound a root
  if np.sign(f(a)) == np.sign(f(b)):
    raise Exception(
        "The scalars a and b do not bound a root")
  # get mid point
  m = (a+b)/2

  if np.abs(f(m)) < tol:
    # stopping condition, report m as root
    return m
  elif np.sign(f(a)) == np.sign(f(m)):


    return my_bisection(f, m, b, tol)

  elif np.sign(f(b)) == np.sign(f(m)):


    return my_bisection(f, a, m, tol)

f = lambda x: x**2 - 2

r1 = my_bisection (f, 0, 2, 0.1)
print("r1=", r1)
r01 = my_bisection (f, 0, 2, 0.01)
print("r01=", r01)

print("f(r1) =", f(r1))
print("f(r01) =", f(r01))

"""Quiz 1 bisection
f(x) = x^3 - 3x^2 + 2x
 [a,b] = [1,2]
  tol = 0.01
"""

f = lambda x: x**3 - 3*x**2 + 2*x
r01 = my_bisection (f, 1, 2, 0.01)
print("r01=", r01)
print("f(r01) =", f(r01))

"""Quiz 2 bisection
f(x) = sin x - x
[a, b] = [0, 1]
tol = 0,001

math.sin(radian)
"""

import math
def f(x):
    return math.sin(x) - x

def bisection(a, b, tol):
    if f(a) * f(b) > 0:
        print("Tidak ada akar dalam interval yang diberikan.")
        return None
    iterasi = 0
    while (b - a) / 2.0 > tol:
        iterasi += 1
        midpoint = (a + b) / 2.0
        if f(midpoint) == 0:
            return midpoint
        elif f(a) * f(midpoint) < 0:
            b = midpoint
        else:
            a = midpoint
    return (a + b) / 2.0

# Menentukan interval dan toleransi
a = 0
b = 1
tol = 0.001

# Menjalankan metode bisection
root = bisection(a, b, tol)
if root is not None:
    print("Akar dari fungsi adalah:", root)